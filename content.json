{"meta":{"title":"Hexo","subtitle":"","description":"","author":"俄罗斯悍匪","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"2022-03-19T02:51:25.330Z","updated":"2022-03-19T02:51:25.330Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个努力学习安全，想要成为俄罗斯悍匪的安全开发工程师。 在这里会分享开发、安全、求职等等相关知识。希望这里有你们需要的知识。 个人公众号"},{"title":"书单","date":"2022-03-18T14:57:07.806Z","updated":"2022-03-18T14:57:07.806Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":"2022年读书计划（1）云原生安全（在读） （2）Go语言精进之路（在读） （3）自控力（在读） （4）心理罪（已读完） （5）把时间当作朋友（在读） （6）长夜难明（在读）"},{"title":"友情链接","date":"2022-03-18T03:13:23.931Z","updated":"2022-01-02T17:09:36.000Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-18T03:13:23.932Z","updated":"2022-01-02T17:09:36.000Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-03-18T03:33:15.379Z","updated":"2022-01-02T17:09:36.000Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"分类","date":"2022-03-18T03:32:34.550Z","updated":"2022-01-02T17:09:36.000Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-18T03:13:23.933Z","updated":"2022-01-02T17:09:36.000Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"云原生安全概述","slug":"云原生安全概述","date":"2022-03-19T03:30:31.000Z","updated":"2022-03-22T03:37:09.834Z","comments":true,"path":"2022/03/19/云原生安全概述/","link":"","permalink":"http://example.com/2022/03/19/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/","excerpt":"","text":"云原生安全概述本系列博客的内容均来源于对“云原生安全：攻防实现与体系构建”这本书籍的学习归纳。 1.1 云原生的含义​ 云计算的上半场基本已经结束，很多企业已经利用开源的或者商业的IaaS系统构建云计算平台，他们只是简单的将传统的物理主机、平台、或者应用转为虚拟化。只实现了“形”上的改变，还远远没有达到“神”上的变化。云计算的下半场，应该充分利用云计算的特性，解决业务在开发、运行整个生命周期中遇到的问题。 ​ CNCF对云原生的解释为：“云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统做出频繁和可预测的重大变更。 1.2 云原生的特性1.2.1 轻、快、不变的基础设施​ 云原生环境中，支撑基础设施通常是容器技术。 ​ 轻、快：容器占用资源小，生命周期短，以秒或者分钟为基本单位。 ​ 不变：在实践中不会在容器中安装或者更新应用，而是更新为更为持久化的镜像。这种只更新镜像而不改变容器运行时的模式称为不变的基础设施。 1.2.2 弹性服务编排​ 云原生的焦点是业务，业务的最核心之处是业务管理和控制。服务编排提供了强大的业务支撑能力，可以弹性的控制服务的位置、容量、版本，监控保证业务的可访问性。 1.2.3 开发运营一体化​ DevOps通过将软件开发和运营相结合，缩短软件开发的生命周期。DevOps的开发理念主要包括自动化构建、测试、持续集成和持续交付等等。 1.2.4 微服务架构​ 将传统的单体应用的功能拆解成大量单独、细粒度的服务。通过应用编排组装，实现等价于传统单体应用的复杂功能。 1.2.5 无服务模型​ 无服务是一种基于代码和计算任务执行的云计算抽象模型，与之相对的是基于服务器（虚拟机、容器）的计算模式。无服务聚焦在函数计算，隐藏了底层复杂的实现方式，使开发者能够聚焦业务本身。 1.2.6 小结​ 云原生就是以云的模式管理和部署资源，用户看到的不是一个虚拟主机，而是一个个业务单元，开发者只需要聚焦于业务本身。微服务的设计、无服务的功能是云原生理念的核心体现，容器、编排、服务网格是实现云原生的支撑技术。 1.3 云原生安全的含义​ 云原生安全分为面向云原生环境的安全和具有云原生特征的安全。 1.3.1 面向云原生环境的安全​ 面向云原生环境的安全是为了保障云原生环境中的基础设施、编排系统和微服务系统的安全。这类安全机制，不一定具备云原生的特征，可以以传统的模式部署、硬件设备等资源来保护云原生环境。 ​ 针对云原生的内部安全机制主要以云原生形态的居多，如服务网格的安全通常使用旁挂串接的安全容器，微服务API安全通常使用API网关容器，容器都是云原生的部署方式，具有云原生的特征。 1.3.2 具有云原生特征的安全​ 借助于业界流行的云原生技术和平台，所提供的具有云原生特征的安全机制，能够提供比安全资源池性能更好、处置更灵活的安全能力。 1.4 云原生安全体系​ 未来的云安全其实就是纯安全，未来的云计算无处不在，谈云安全问题，就是谈一个通用场景下的安全问题。 ​ 云原生安全演进如图所示： 云原生发展会有三个阶段： （1）安全赋能云原生体系，构建云原生的安全能力。当前云原生技术发展迅速，但相应的安全防护匮乏，基础的镜像安全、安全基线都没有成熟的方案。因此，需要研究如何将现有的安全策略，比如隔离、访问控制、入侵检测、应用安全等等应用到云原生环境，构建安全的云原生系统，是当前需要考虑的问题。 （2）安全产品具有云原生的新特性，该阶段需要研究的是将轻&#x2F;快&#x2F;不变的基础设施、弹性服务编排、开发运营一体化的云原生特性赋予到传统的安全产品上，通过软件定义的安全架构，构建原生安全架构，提供弹性、按需、云原生的安全能力。 （3）提高通用性，安全设备或者平台云原生化后，所提高的安全额能力，不仅适用于云原生、5G、边缘计算场景，还可以独立部署在大型电商等传统常见，最终成为无处不在的安全。 根据云原生环境的构成，面向云原生环境的安全体系包含三个层面的安全机制。 1.4.1 容器安全​ 容器环境是云计算的实现的一种方式，因此，容器层面的安全分为以下几部分。 ​ （1）容器环境基础设施的安全性，比如主机上的安全配置是否会影响到其上运行的容器，主机上的安全漏洞和恶意进程是否会影响到容器，容器内的进程是否可以利用主机上的安全漏洞，等等。 ​ （2）容器的镜像安全，包括镜像中的软件是否存在安全漏洞，镜像在构建过程中是否存在安全风险，镜像在传输过程中是否被恶意篡改。 ​ （3）容器运行时安全，比如运行的容器间的隔离是否充分，容器间的通信是否是安全的，容器内的恶意程序是否会影响到主机或者其他容器，容器的资源使用情况是否安全等等。 ​ （4）整个容器生态的安全性，比如Docker自身的安全性如何，Service Mesh&#x2F;Serverless对容器安全的影响，容器中的安全密钥的管理与传统环境有什么不同，容器化后的数据隐私保护与传统的数据隐私保护是否一致。 容器安全可以粗略的分为两个主要方面：一方面是容器云内部的安全，包括宿主机安全、虚拟化安全，容器（东西向）网络的安全，管理平台的安全以及数据安全等等；另一方面是容器云内外之间的网络安全，也就是通常讲的南北向网络安全。其中东西向指的是容器之间的安全，南北向指的是容器和外部之间的安全。 云计算安全架构如图所示： 容器云安全建设思路 1.4.2 编排系统安全​ 编排系统的安全指的主要是针对Kubernetes的安全。 1.4.3 云原生应用安全​ 新型的微服务提醒中存在的安全风险 1.5 云原生安全问题1.5.1 如何防护段生命周期的容器​ 容器的生命周期啊分布呈现三种类型。 （1）虚拟机型：有一小部分容器被当成虚拟机使用，将本来放置于一个虚拟机中的程序集合部署到单个容器中，这些容器的生命周期和虚拟机相当。生命周期平均在83-333天左右。 （2）原生型：有一部分容器是以Docker的命令启动和管理的，这部分容器完成独立的功能，生命周期在10天左右 （3）编排型：还有大量的容器是由编排系统管理的，很多容器更具业务动态生成和销毁，这类容器的生命周期在1天以内。 ​ 攻击者关注的更多的是持久化的东西，比如代码、第三方库、镜像资产等等。 ​ 对于防守者来说，安装杀毒软件，对容器来说是一个相对不可行的技术，杀毒软件相对容器而言太重了。 ​ 因此如何保护短生命周期的容器是我们需要解决的问题之一。 1.5.2 如何降低安全运营成本​ 安全左移：将安全防护从传统运行时运营转向为开发侧 1.5.3 DevSecOps​ DevSecOps开发运营一体化安全，安全能力应该覆盖开发和运营闭环的每个环节。 1.5.4 如何实现安全的云原生化（1）安全架构具备编排能力 ​ 编排是指将各类资源根据业务需要进行动态控制和管理，安全架构可以借助编排系统实现动态化的管理和升级。 （2）容器和宿主机安全：安全特权容器 ​ 以安全容器的形式防护容器的安全，由于容器技术是操作系统的虚拟化，所以可以通过宿主机中的安全代理观察到容器中的进程、文化系统等消息。 （3）Sidecar安全容器 ​ 特权容器通常关心的是系统调用、网络流量，但是在云原生环境下，业务团队更加关心的是容器承载的业务的安全。这些安全主要是针对应用层的防护，针对应用层的防护，主要使用的是Sidecar模式的安全容器。 ​ Sidecar容器本质上就是一种提供反向代理的容器，如图所示，该容器会劫持业务容器的流量，经过解析获得应用层的请求和响应，然后根据安全策略进行检测或防护。 1.6 云原生现状1.6.1 云原生新范式：Docker+Kubernetes​ 如图所示，Docker、Containerd和CRI-O是容器运行时的主流实现机制： ​ 如图所示，在编排工具上，Kubernetes占据了榜首。 1.6.2 镜像问题仍然突出​ Docker Hub上的官方惊醒，存在高危漏洞。主要问题来源于两方面：方面一：缺少安全团队对镜像的安全性进行检测。方面二：主要是镜像未及时更新安全补丁。 1.6.3 安全配置规范执行和密钥凭证管理不理想​ 云原生应用会大量存在应用与中间件、后端服务的交互，为了简便，很多开发者将访问凭证、密钥文件直接存放在代码中，或者将一些线上资源的访问品证设置为空或弱口令，导致攻击者很容易访问敏感数据的权限。 1.7本章小结​ 通过本章的学习，了解云原生的含义，根据云原生和安全体系的关系和发展阶段，首次提出了原生安全的概念，然后介绍了云安全中的一些亟待解决的关键问题。 欢迎各位关注个人公众号，一起讨论学习。个人博客地址： https://thenorth-sec.github.io/","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"云安全","slug":"云安全","permalink":"http://example.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"}]},{"title":"javascript学习","slug":"javascript学习","date":"2022-03-18T15:04:36.000Z","updated":"2022-03-19T03:04:12.208Z","comments":true,"path":"2022/03/18/javascript学习/","link":"","permalink":"http://example.com/2022/03/18/javascript%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"JavaScript1. 变量 (1) 变量的定义 const 和 let, 其中const 定义的是常量，不可以重复赋值，一般来说数据不可改变, let定义的变量是可以改变的 12let num = 123;alert(num); (2) JS 中常用的变量类型： ​ 1) String ​ 2) Boolean ​ 3) Numbers ​ 4) object: Array, Undefined, Null 12345678910111213141516171819202122const num_1 = 111;const num_2 = 1.1; // 在js中Number类型是不分整型和浮点型的const str_test = &quot;abc&quot;; // String 类型const bool_test = true;let array_test = [1,2,3];let undefined_test = undefined;console.log(&quot;typeof num_1&quot;, typeof num_1);console.log(&quot;typeof num_2&quot;, typeof num_2);console.log(&quot;typeof str_test&quot;, typeof str_test);console.log(&quot;typeof bool_test&quot;, typeof bool_test);console.log(&quot;typeof array_test&quot;, typeof array_test);console.log(&quot;typeof undefined_test&quot;, typeof undefined_test); (3) 字符串的相关操作 ​ 1) 字符串拼接 12345678910111213console.log(&quot;num_1 = &quot; + num_1,&#x27;and num_2 = &#x27; + num_2);console.log(`num_1 = $&#123;num_1&#125;, num_2 = $&#123;num_2&#125;`);console.log(&quot;str_test length = &quot; + str_test.length); // 属性没有括号，方法才有括号console.log(&quot;str_test toLocalUpperCase=&quot;,str_test.toLocaleUpperCase())console.log(&quot;str_test substring(0,2)&quot;, str_test.substring(0,2))let new_str = &quot;a b c&quot;console.log(&quot;new_str split&quot;,new_str.split(&quot; &quot;)) ​ 2.数组（1） 数组的相关操作 1234567891011121314151617const new_array = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]console.log(&quot;new_array[1]&quot;,new_array[1])new_array[2] = &quot;d&quot; // const 定义的数组对象是可以修改的new_array.push(&quot;e&quot;) // 在末尾添加元素new_array.unshift(&quot;1&quot;) // 在头部添加元素new_array.pop() //去掉最尾的元素console.log(new_array)console.log(&quot;Array.isArray(new_array)&quot;,Array.isArray(new_array))console.log(&quot;new_array.indexOf(&#x27;a&#x27;)&quot;,new_array.indexOf(&#x27;a&#x27;)) 3.对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const person = &#123; firstName: &quot;John&quot;, lastName: &quot;Doe&quot;, age: 30, hobbies: [&#x27;music&#x27;, &#x27;movies&#x27;, &#x27;sports&#x27;], address :&#123; street: &quot;50 main st&quot;, city: &quot;Boston&quot;, state: &quot;NA&quot; &#125;&#125;console.log(&#x27;person&#x27;, person)console.log(&#x27;persom.firstName&#x27;, person[&#x27;firstName&#x27;])console.log(&#x27;person.hobbies[0]&#x27;, person.hobbies[0])console.log(&#x27;person.address.street&#x27;, person.address.street)const&#123; firstName, lastName, address: &#123;city&#125;&#125; = person; // 直接抓取person对象中的属性值console.log(&quot;firstName=&quot;,firstName)console.log(&quot;city=&quot;,city)const todos = [ &#123; id: 1, Name: &quot;Jack&quot; &#125;, &#123; id: 2, Name: &quot;Tom&quot; &#125;];console.log(&quot;todos&quot;,todos)console.log(&quot;todos[1].Name=&quot;,todos[1].Name)//转换成json格式const todoJson = JSON.stringify(todos)console.log(todoJson) 4. 循环语句(1) for 相关语句 123for(let i = 0; i &lt; 6; i++)&#123; console.log(`i=$&#123;i&#125;`)&#125; (2) while 相关语句 123456let num = 0while(num &lt; 6)&#123; console.log(&quot;num = &quot;, num); num++&#125; (3) for-each的使用 123456789101112131415161718const todos = [ &#123; Id: 1, Name: &quot;Jack&quot; &#125;,&#123; Id: 2, Name: &quot;Tom&quot; &#125;,&#123; Id: 3, Name: &quot;Jerry&quot; &#125;,]todos.forEach( function(t)&#123; console.log(&quot;t.Name = &quot;, t.Name) &#125;) (4) map的使用 12345678//map 返回一个数组const t = todos.map( function(t)&#123; return t.Id; &#125;)console.log(&quot;t = &quot;, t) (5) filter 过滤器，过滤满足条件的数据 12345const tName = todos.filter( function(t)&#123; return t.Name.length &gt; 3; &#125;) 5.判断语句123456789101112131415161718192021222324252627// if 语句let num = 1;if(num == 1)&#123; // == 值判断值是否相等，不判断类型是否相等 console.log(&quot;num = &quot;, num)&#125;if(num == &#x27;1&#x27;)&#123; // == 值判断值是否相等，不判断类型是否相等 console.log(&quot;num = &quot;, num)&#125;if(num === 1)&#123; // 不仅要判断值是否相等，类型也需要判断 console.log(&quot;num = &quot;, num)&#125;let score = 90if (score &gt;= 60 &amp;&amp; score &lt;= 70)&#123; console.log(&quot;成绩及格了&quot;)&#125;else if(score &gt; 70)&#123; console.log(&quot;优秀&quot;)&#125;else&#123; console.log(&quot;不及格&quot;)&#125; 6. 逻辑运算注意： 12false: undefined, 0, &#x27;&#x27;,null, false //这些值默认是falsetrue:除了上述一般来说都是true （1）与 &amp;&amp; 123456789let score = 60if (score &gt; 60 &amp;&amp; score &lt; 70)&#123; console.log(&quot;良&quot;)&#125;else if(score &gt;= 70)&#123; console.log(&quot;优秀&quot;)&#125;else&#123; console.log(&quot;不及格&quot;)&#125; (2) 或 || 12345if(age &lt; 0 || age &gt; 200)&#123; console.log(&quot;非法年龄&quot;)&#125;else&#123; console.log(&quot;age=&quot;, age)&#125; (3) 三元运算符 12345const xxx = 9;const color = xxx &gt; 10 ? &#x27;red&#x27; : &#x27;green&#x27;;console.log(&quot;color = &quot;,color) (4) switch 语句 123456789101112131415// switch 语句let color = &quot;red&quot;switch (color)&#123; case &#x27;red&#x27;: console.log(&quot;红色&quot;); break; case &#x27;blue&#x27;: console.log(&quot;蓝色&quot;); break; default: console.log(&quot;未知&quot;); break;&#125; 7. 函数（1）普通函数 注意： 普通函数的首字母是不可以大写的 12345678910console.log(&quot;function 函数演示&quot;)//普通函数第一个字母是不可以大写的function add(num_1 = 0, num_2 = 0)&#123; return num_1 + num_2&#125;let res = add(1,2)console.log(&quot;res = &quot;, res) (2) 箭头函数（相当于匿名函数） 注意： 匿名函数必须有变量接收 12345678910111213141516171819202122232425262728// 箭头函数// 上述函数并不能改造为箭头函数，去掉函数名add才可以// 匿名函数必须要有变量进行接收const kniferes = (num_1, num_2) =&gt;&#123; return num_1+num_2&#125;addres = kniferes(1,2)console.log(addres)// 如果箭头函数只有一行，且不是return指令是可以这样编写的const singleline = () =&gt; console.log(&quot;123&quot;)singleline()// 取代returnconst addline = (num_1, num_2) =&gt; num_1 + num_2console.log(&quot;addline(1,2) = &quot;, addline(1,2))//只有一个形参，无初始值const test = num_1 =&gt; num_1 + 12;console.log(&quot;test=&quot;,test(1)) 8. 对象12345678910111213141516// 面向对象的基础演示, 只要带上&#123;&#125;,就是一个对象const book_1 = &#123; title : &quot;明朝那些事&quot;, author: &quot;朱元璋&quot;, year: &quot;2013&quot;, getSummary: function()&#123; return `$&#123;this.author&#125; 在 $&#123;this.year&#125; 写了 $&#123;this.title&#125;` &#125;&#125;console.log(book_1.getSummary())console.log(&quot;Object.Keys(book_1)&quot;, Object.keys(book_1))console.log(&quot;Object.Values(book_1)&quot;, Object.values(book_1)) 9. 构造函数（1）构造函数，相当于其他语言中类的概念 存在的问题： 比如构造函数中存在方法，这个时候会在所有的对象中创建该方法。造成了内存的浪费。 因此，JS为了解决上述问题，推出了原型链的概念 123456789101112131415161718192021222324/* 注意：类是对象的模板，对象是类的实例 但是ES6之前，js是不存在类的概念的，js不是基于类，而是通过构造函数*//*构造函数 a. 构造函数的首字母必须大写，用来区分于普通函数 b. 内部使用的this对象，来指向要生成的实例对象 c. 使用New来生成对象*/function Book(title, author, year)&#123; this.title = title; this.author = author; this.year = year; this.getSummary = function()&#123; return `$&#123;this.author&#125; 在 $&#123;this.year&#125; 写了 $&#123;this.title&#125;这篇文章` &#125;&#125;book_1 = new Book(&quot;明朝那些事&quot;, &quot;朱元璋&quot;,&quot;2020&quot;)console.log(book_1.getSummary()) （2）原型链 通过原型链创建构造函数的方法，只有对象使用时，才会创建。 1234567891011121314/* 原型链*/function Book(title, author, year)&#123; this.title = title; this.author = author; this.year = year&#125;Book.prototype.getSummary = function()&#123; return `$&#123;this.author&#125; 在 $&#123;this.year&#125; 写了 $&#123;this.title&#125;`&#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"前端学习","slug":"前端学习","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"css学习","slug":"css学习","date":"2022-03-18T15:04:36.000Z","updated":"2022-03-19T03:03:57.324Z","comments":true,"path":"2022/03/18/css学习/","link":"","permalink":"http://example.com/2022/03/18/css%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"CSS 相关知识点1. 样式的优先级行内样式 &gt; 内部样式 、 外部样式 其中针对内部样式和外部样式采用的是就近原则，谁距离标签比较近，就使用睡得样式表。 2.选择器2.1 基本选择器为了获取页面的的元素 （1）标签选择器 （2）类选择器 （3）id选择器 12345678910111213&lt;h1 class=&quot;myh1&quot; id=&#x27;name&#x27;&gt;1111&lt;/h1&gt;&lt;style&gt; h1&#123; color: red; &#125; .myh1&#123; background-color:black; &#125; #name&#123; font-size:40px; &#125;&lt;/style&gt; 选择器的优先级顺序： ​ id选择器 &gt; class 选择器 &gt; 标签选择器 2.2 层次选择器12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;h1&gt;测试&lt;/h1&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;p&gt;p4&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;p5&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;p6&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;style&gt; &lt;/style&gt;&lt;/html&gt; 1、后代选择器 所有的后代 12345&lt;style&gt; body p&#123; background-color: aquamarine; &#125;&lt;/style&gt; 2、子选择器 只有最近的子代 12345&lt;style&gt; body&gt;p&#123; background-color: aquamarine; &#125;&lt;/style&gt; 3、相邻兄弟选择器 只有一个，相邻向下 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;h1&gt;测试&lt;/h1&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p class=&quot;active&quot;&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;p&gt;p4&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;p5&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;p6&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;style&gt; .active + p &#123; background-color: aquamarine; &#125;&lt;/style&gt;&lt;/html&gt; 4.通用选择器 当前选中元素的向下的所有兄弟元素 12345&lt;style&gt; .active ~ p &#123; background-color: aquamarine; &#125;&lt;/style&gt; 2.3 结构伪类选择器我觉得意义不大 2.4 属性选择器属性选择器可以根据元素的属性或者属性值来选择元素 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;h1&gt;测试&lt;/h1&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p class=&quot;active&quot;&gt;p2&lt;/p&gt; &lt;p class=&quot;active node&quot;&gt;p3&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;p class=&quot;active node&quot;&gt;p4&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;p5&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;p6&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;style&gt; /* 不加~就是完全匹配 */ body p[class~=&quot;active&quot;]&#123; background-color: aquamarine; &#125;&lt;/style&gt;&lt;/html&gt; 3.样式3.1 字体样式1234font-family: 字体font-size: 字体大小font-weight: 字体粗细color: 字体颜色 3.2 文本样式 颜色 文本对齐方式 1text-align: center; 首行缩进 12/* em代表缩进一个字 */text-indent: 2em; 行高 行高和块的高度一致时，就可以保证文本上下居中。 1line-height: 300px; 下划线 1text-decoration: underline; 文本图片水平对齐 1234567891011&lt;body&gt; &lt;img src=&quot;../../public/favicon.ico&quot; class=&quot;favicon&quot;&gt; &lt;span class=&quot;spantext&quot;&gt;111111111111111111111&lt;/span&gt;&lt;/body&gt;&lt;style&gt; /* 逗号左边的参数是参照物 */ .favivon,spantext&#123; vertical-align: middle; &#125;&lt;/style&gt; 3.3 文本阴影和超链接伪类3.3.1 超链接的相关伪类12345678910&lt;style&gt; /* 鼠标在超链接上时的相关样式 */ a:hover&#123; color: aquamarine; &#125; /* 鼠标点击超链接时的相关样式 */ a:active&#123; color: bisque; &#125;&lt;/style&gt; 3.3.2 文本阴影3.4 列表3.4.1 相关样式12345678/* 列表开头的相关样式：none 去掉原点circle 空心圆decimal 数字square 正方形*/line-style: none; 3.5 背景3.5.1 背景颜色3.5.2 背景图片4.盒子模型 margin: 外边框 padding: 内边框 border: 边框 4.2 边框 边框的粗细 边框的样式 边框的颜色 1border: 2px solid red; 4.3 外边框外边框水平居中 注意：如果margin: 0 auto; 未生效 在body中将text-align属性设置未center就行。 1234/* 水平居中 首先外面是一个块元素，块元素外面有长度限制*/margin:0 auto; /* 上边距20px,下边距30px,左边距10px,右边距40px */margin:20px 30px 10px 40px; 4.4 圆角边框12/* 左上 右上 右下 左下 */border-radius: 20px 20px 10px 10px; 4.5 阴影1box-shadow: ; 5. 浮动5.1 行内元素行内元素： 与其他行内元素并排 不能设置宽高，默认的宽度就是文字的宽度 5.2 块级元素块级元素： 霸占一行，不能与其他任何元素并列。 能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%。 5.2.1块级元素和行内元素的分类： 在HTML的角度来讲，标签分为： 文本级标签：p , span , a , b , i , u , em 容器级标签：div , h系列 , li , dt ,dd p：里面只能放文字和图片和表单元素，p里面不能放h和ul，也不能放p。 从CSS的角度讲，CSS的分类和上面的很像，就p不一样： 行内元素：除了p之外，所有的文本级标签，都是行内元素。p是个文本级标签，但是是个块级元素。 块级元素：所有的容器级标签，都是块级元素，以及p标签。 5.2.2块级元素和行内元素的相互转换： 我们可以通过display属性将块级元素(比如div)和行内元素进行相互转换。 display：inline; 那么这个标签将变为行内元素，即： 1，此时这个div将不能设置宽度和高度了。 2，此时这个div可以和其他行内元素并排了。 同样的到了我们也可以用display将行内元素(比如span)转行成块级元素。 display：block； 那么这个span标签将变为块级标签，即： 1，此时这个span能够设置宽度，高度。 2，此时这个span必须独占一行，其他元素无法与之并排。 3，如果不设置宽度，将占满父级。","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"前端学习","slug":"前端学习","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"云安全","slug":"云安全","permalink":"http://example.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"前端学习","slug":"前端学习","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]}