{"meta":{"title":"Hexo","subtitle":"","description":"","author":"俄罗斯悍匪","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-03-18T03:33:15.379Z","updated":"2022-01-02T17:09:36.000Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2022-03-18T14:57:07.806Z","updated":"2022-03-18T14:57:07.806Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":"2022年读书计划（1）云原生安全（在读） （2）Go语言精进之路（在读） （3）自控力（在读） （4）心理罪（已读完） （5）把时间当作朋友（在读） （6）长夜难明（在读）"},{"title":"分类","date":"2022-03-18T03:32:34.550Z","updated":"2022-01-02T17:09:36.000Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-03-19T01:26:36.511Z","updated":"2022-03-19T01:26:36.511Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个努力学习安全，想要成为俄罗斯悍匪的安全开发工程师。在这里会分享开发、安全、求职等等相关知识。希望这里有你们需要的知识。"},{"title":"标签","date":"2022-03-18T03:13:23.933Z","updated":"2022-01-02T17:09:36.000Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-03-18T03:13:23.931Z","updated":"2022-01-02T17:09:36.000Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-18T03:13:23.932Z","updated":"2022-01-02T17:09:36.000Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"css学习","slug":"css学习","date":"2022-03-18T15:04:36.000Z","updated":"2022-03-18T15:13:52.633Z","comments":true,"path":"2022/03/18/css学习/","link":"","permalink":"http://example.com/2022/03/18/css%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"CSS 相关知识点1. 样式的优先级行内样式 &gt; 内部样式 、 外部样式 其中针对内部样式和外部样式采用的是就近原则，谁距离标签比较近，就使用睡得样式表。 2.选择器2.1 基本选择器为了获取页面的的元素 （1）标签选择器 （2）类选择器 （3）id选择器 12345678910111213&lt;h1 class=&quot;myh1&quot; id=&#x27;name&#x27;&gt;1111&lt;/h1&gt;&lt;style&gt; h1&#123; color: red; &#125; .myh1&#123; background-color:black; &#125; #name&#123; font-size:40px; &#125;&lt;/style&gt; 选择器的优先级顺序： ​ id选择器 &gt; class 选择器 &gt; 标签选择器 2.2 层次选择器12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;h1&gt;测试&lt;/h1&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;p&gt;p4&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;p5&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;p6&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;style&gt; &lt;/style&gt;&lt;/html&gt; 1、后代选择器 所有的后代 12345&lt;style&gt; body p&#123; background-color: aquamarine; &#125;&lt;/style&gt; 2、子选择器 只有最近的子代 12345&lt;style&gt; body&gt;p&#123; background-color: aquamarine; &#125;&lt;/style&gt; 3、相邻兄弟选择器 只有一个，相邻向下 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;h1&gt;测试&lt;/h1&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p class=&quot;active&quot;&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;p&gt;p4&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;p5&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;p6&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;style&gt; .active + p &#123; background-color: aquamarine; &#125;&lt;/style&gt;&lt;/html&gt; 4.通用选择器 当前选中元素的向下的所有兄弟元素 12345&lt;style&gt; .active ~ p &#123; background-color: aquamarine; &#125;&lt;/style&gt; 2.3 结构伪类选择器我觉得意义不大 2.4 属性选择器属性选择器可以根据元素的属性或者属性值来选择元素 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;h1&gt;测试&lt;/h1&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p class=&quot;active&quot;&gt;p2&lt;/p&gt; &lt;p class=&quot;active node&quot;&gt;p3&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;p class=&quot;active node&quot;&gt;p4&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;p5&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;p6&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;style&gt; /* 不加~就是完全匹配 */ body p[class~=&quot;active&quot;]&#123; background-color: aquamarine; &#125;&lt;/style&gt;&lt;/html&gt; 3.样式3.1 字体样式1234font-family: 字体font-size: 字体大小font-weight: 字体粗细color: 字体颜色 3.2 文本样式 颜色 文本对齐方式 1text-align: center; 首行缩进 12/* em代表缩进一个字 */text-indent: 2em; 行高 行高和块的高度一致时，就可以保证文本上下居中。 1line-height: 300px; 下划线 1text-decoration: underline; 文本图片水平对齐 1234567891011&lt;body&gt; &lt;img src=&quot;../../public/favicon.ico&quot; class=&quot;favicon&quot;&gt; &lt;span class=&quot;spantext&quot;&gt;111111111111111111111&lt;/span&gt;&lt;/body&gt;&lt;style&gt; /* 逗号左边的参数是参照物 */ .favivon,spantext&#123; vertical-align: middle; &#125;&lt;/style&gt; 3.3 文本阴影和超链接伪类3.3.1 超链接的相关伪类12345678910&lt;style&gt; /* 鼠标在超链接上时的相关样式 */ a:hover&#123; color: aquamarine; &#125; /* 鼠标点击超链接时的相关样式 */ a:active&#123; color: bisque; &#125;&lt;/style&gt; 3.3.2 文本阴影3.4 列表3.4.1 相关样式12345678/* 列表开头的相关样式：none 去掉原点circle 空心圆decimal 数字square 正方形*/line-style: none; 3.5 背景3.5.1 背景颜色3.5.2 背景图片4.盒子模型 margin: 外边框 padding: 内边框 border: 边框 4.2 边框 边框的粗细 边框的样式 边框的颜色 1border: 2px solid red; 4.3 外边框外边框水平居中 注意：如果margin: 0 auto; 未生效 在body中将text-align属性设置未center就行。 1234/* 水平居中 首先外面是一个块元素，块元素外面有长度限制*/margin:0 auto; /* 上边距20px,下边距30px,左边距10px,右边距40px */margin:20px 30px 10px 40px; 4.4 圆角边框12/* 左上 右上 右下 左下 */border-radius: 20px 20px 10px 10px; 4.5 阴影1box-shadow: ; 5. 浮动5.1 行内元素行内元素： 与其他行内元素并排 不能设置宽高，默认的宽度就是文字的宽度 5.2 块级元素块级元素： 霸占一行，不能与其他任何元素并列。 能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%。 5.2.1块级元素和行内元素的分类： 在HTML的角度来讲，标签分为： 文本级标签：p , span , a , b , i , u , em 容器级标签：div , h系列 , li , dt ,dd p：里面只能放文字和图片和表单元素，p里面不能放h和ul，也不能放p。 从CSS的角度讲，CSS的分类和上面的很像，就p不一样： 行内元素：除了p之外，所有的文本级标签，都是行内元素。p是个文本级标签，但是是个块级元素。 块级元素：所有的容器级标签，都是块级元素，以及p标签。 5.2.2块级元素和行内元素的相互转换： 我们可以通过display属性将块级元素(比如div)和行内元素进行相互转换。 display：inline; 那么这个标签将变为行内元素，即： 1，此时这个div将不能设置宽度和高度了。 2，此时这个div可以和其他行内元素并排了。 同样的到了我们也可以用display将行内元素(比如span)转行成块级元素。 display：block； 那么这个span标签将变为块级标签，即： 1，此时这个span能够设置宽度，高度。 2，此时这个span必须独占一行，其他元素无法与之并排。 3，如果不设置宽度，将占满父级。","categories":[],"tags":[{"name":"前端学习","slug":"前端学习","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"javascript学习","slug":"javascript学习","date":"2022-03-18T15:04:36.000Z","updated":"2022-03-18T15:12:48.066Z","comments":true,"path":"2022/03/18/javascript学习/","link":"","permalink":"http://example.com/2022/03/18/javascript%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"JavaScript1. 变量 (1) 变量的定义 const 和 let, 其中const 定义的是常量，不可以重复赋值，一般来说数据不可改变, let定义的变量是可以改变的 12let num = 123;alert(num); (2) JS 中常用的变量类型： ​ 1) String ​ 2) Boolean ​ 3) Numbers ​ 4) object: Array, Undefined, Null 12345678910111213141516171819202122const num_1 = 111;const num_2 = 1.1; // 在js中Number类型是不分整型和浮点型的const str_test = &quot;abc&quot;; // String 类型const bool_test = true;let array_test = [1,2,3];let undefined_test = undefined;console.log(&quot;typeof num_1&quot;, typeof num_1);console.log(&quot;typeof num_2&quot;, typeof num_2);console.log(&quot;typeof str_test&quot;, typeof str_test);console.log(&quot;typeof bool_test&quot;, typeof bool_test);console.log(&quot;typeof array_test&quot;, typeof array_test);console.log(&quot;typeof undefined_test&quot;, typeof undefined_test); (3) 字符串的相关操作 ​ 1) 字符串拼接 12345678910111213console.log(&quot;num_1 = &quot; + num_1,&#x27;and num_2 = &#x27; + num_2);console.log(`num_1 = $&#123;num_1&#125;, num_2 = $&#123;num_2&#125;`);console.log(&quot;str_test length = &quot; + str_test.length); // 属性没有括号，方法才有括号console.log(&quot;str_test toLocalUpperCase=&quot;,str_test.toLocaleUpperCase())console.log(&quot;str_test substring(0,2)&quot;, str_test.substring(0,2))let new_str = &quot;a b c&quot;console.log(&quot;new_str split&quot;,new_str.split(&quot; &quot;)) ​ 2.数组（1） 数组的相关操作 1234567891011121314151617const new_array = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]console.log(&quot;new_array[1]&quot;,new_array[1])new_array[2] = &quot;d&quot; // const 定义的数组对象是可以修改的new_array.push(&quot;e&quot;) // 在末尾添加元素new_array.unshift(&quot;1&quot;) // 在头部添加元素new_array.pop() //去掉最尾的元素console.log(new_array)console.log(&quot;Array.isArray(new_array)&quot;,Array.isArray(new_array))console.log(&quot;new_array.indexOf(&#x27;a&#x27;)&quot;,new_array.indexOf(&#x27;a&#x27;)) 3.对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const person = &#123; firstName: &quot;John&quot;, lastName: &quot;Doe&quot;, age: 30, hobbies: [&#x27;music&#x27;, &#x27;movies&#x27;, &#x27;sports&#x27;], address :&#123; street: &quot;50 main st&quot;, city: &quot;Boston&quot;, state: &quot;NA&quot; &#125;&#125;console.log(&#x27;person&#x27;, person)console.log(&#x27;persom.firstName&#x27;, person[&#x27;firstName&#x27;])console.log(&#x27;person.hobbies[0]&#x27;, person.hobbies[0])console.log(&#x27;person.address.street&#x27;, person.address.street)const&#123; firstName, lastName, address: &#123;city&#125;&#125; = person; // 直接抓取person对象中的属性值console.log(&quot;firstName=&quot;,firstName)console.log(&quot;city=&quot;,city)const todos = [ &#123; id: 1, Name: &quot;Jack&quot; &#125;, &#123; id: 2, Name: &quot;Tom&quot; &#125;];console.log(&quot;todos&quot;,todos)console.log(&quot;todos[1].Name=&quot;,todos[1].Name)//转换成json格式const todoJson = JSON.stringify(todos)console.log(todoJson) 4. 循环语句(1) for 相关语句 123for(let i = 0; i &lt; 6; i++)&#123; console.log(`i=$&#123;i&#125;`)&#125; (2) while 相关语句 123456let num = 0while(num &lt; 6)&#123; console.log(&quot;num = &quot;, num); num++&#125; (3) for-each的使用 123456789101112131415161718const todos = [ &#123; Id: 1, Name: &quot;Jack&quot; &#125;,&#123; Id: 2, Name: &quot;Tom&quot; &#125;,&#123; Id: 3, Name: &quot;Jerry&quot; &#125;,]todos.forEach( function(t)&#123; console.log(&quot;t.Name = &quot;, t.Name) &#125;) (4) map的使用 12345678//map 返回一个数组const t = todos.map( function(t)&#123; return t.Id; &#125;)console.log(&quot;t = &quot;, t) (5) filter 过滤器，过滤满足条件的数据 12345const tName = todos.filter( function(t)&#123; return t.Name.length &gt; 3; &#125;) 5.判断语句123456789101112131415161718192021222324252627// if 语句let num = 1;if(num == 1)&#123; // == 值判断值是否相等，不判断类型是否相等 console.log(&quot;num = &quot;, num)&#125;if(num == &#x27;1&#x27;)&#123; // == 值判断值是否相等，不判断类型是否相等 console.log(&quot;num = &quot;, num)&#125;if(num === 1)&#123; // 不仅要判断值是否相等，类型也需要判断 console.log(&quot;num = &quot;, num)&#125;let score = 90if (score &gt;= 60 &amp;&amp; score &lt;= 70)&#123; console.log(&quot;成绩及格了&quot;)&#125;else if(score &gt; 70)&#123; console.log(&quot;优秀&quot;)&#125;else&#123; console.log(&quot;不及格&quot;)&#125; 6. 逻辑运算注意： 12false: undefined, 0, &#x27;&#x27;,null, false //这些值默认是falsetrue:除了上述一般来说都是true （1）与 &amp;&amp; 123456789let score = 60if (score &gt; 60 &amp;&amp; score &lt; 70)&#123; console.log(&quot;良&quot;)&#125;else if(score &gt;= 70)&#123; console.log(&quot;优秀&quot;)&#125;else&#123; console.log(&quot;不及格&quot;)&#125; (2) 或 || 12345if(age &lt; 0 || age &gt; 200)&#123; console.log(&quot;非法年龄&quot;)&#125;else&#123; console.log(&quot;age=&quot;, age)&#125; (3) 三元运算符 12345const xxx = 9;const color = xxx &gt; 10 ? &#x27;red&#x27; : &#x27;green&#x27;;console.log(&quot;color = &quot;,color) (4) switch 语句 123456789101112131415// switch 语句let color = &quot;red&quot;switch (color)&#123; case &#x27;red&#x27;: console.log(&quot;红色&quot;); break; case &#x27;blue&#x27;: console.log(&quot;蓝色&quot;); break; default: console.log(&quot;未知&quot;); break;&#125; 7. 函数（1）普通函数 注意： 普通函数的首字母是不可以大写的 12345678910console.log(&quot;function 函数演示&quot;)//普通函数第一个字母是不可以大写的function add(num_1 = 0, num_2 = 0)&#123; return num_1 + num_2&#125;let res = add(1,2)console.log(&quot;res = &quot;, res) (2) 箭头函数（相当于匿名函数） 注意： 匿名函数必须有变量接收 12345678910111213141516171819202122232425262728// 箭头函数// 上述函数并不能改造为箭头函数，去掉函数名add才可以// 匿名函数必须要有变量进行接收const kniferes = (num_1, num_2) =&gt;&#123; return num_1+num_2&#125;addres = kniferes(1,2)console.log(addres)// 如果箭头函数只有一行，且不是return指令是可以这样编写的const singleline = () =&gt; console.log(&quot;123&quot;)singleline()// 取代returnconst addline = (num_1, num_2) =&gt; num_1 + num_2console.log(&quot;addline(1,2) = &quot;, addline(1,2))//只有一个形参，无初始值const test = num_1 =&gt; num_1 + 12;console.log(&quot;test=&quot;,test(1)) 8. 对象12345678910111213141516// 面向对象的基础演示, 只要带上&#123;&#125;,就是一个对象const book_1 = &#123; title : &quot;明朝那些事&quot;, author: &quot;朱元璋&quot;, year: &quot;2013&quot;, getSummary: function()&#123; return `$&#123;this.author&#125; 在 $&#123;this.year&#125; 写了 $&#123;this.title&#125;` &#125;&#125;console.log(book_1.getSummary())console.log(&quot;Object.Keys(book_1)&quot;, Object.keys(book_1))console.log(&quot;Object.Values(book_1)&quot;, Object.values(book_1)) 9. 构造函数（1）构造函数，相当于其他语言中类的概念 存在的问题： 比如构造函数中存在方法，这个时候会在所有的对象中创建该方法。造成了内存的浪费。 因此，JS为了解决上述问题，推出了原型链的概念 123456789101112131415161718192021222324/* 注意：类是对象的模板，对象是类的实例 但是ES6之前，js是不存在类的概念的，js不是基于类，而是通过构造函数*//*构造函数 a. 构造函数的首字母必须大写，用来区分于普通函数 b. 内部使用的this对象，来指向要生成的实例对象 c. 使用New来生成对象*/function Book(title, author, year)&#123; this.title = title; this.author = author; this.year = year; this.getSummary = function()&#123; return `$&#123;this.author&#125; 在 $&#123;this.year&#125; 写了 $&#123;this.title&#125;这篇文章` &#125;&#125;book_1 = new Book(&quot;明朝那些事&quot;, &quot;朱元璋&quot;,&quot;2020&quot;)console.log(book_1.getSummary()) （2）原型链 通过原型链创建构造函数的方法，只有对象使用时，才会创建。 1234567891011121314/* 原型链*/function Book(title, author, year)&#123; this.title = title; this.author = author; this.year = year&#125;Book.prototype.getSummary = function()&#123; return `$&#123;this.author&#125; 在 $&#123;this.year&#125; 写了 $&#123;this.title&#125;`&#125;","categories":[],"tags":[{"name":"前端学习","slug":"前端学习","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]}],"categories":[],"tags":[{"name":"前端学习","slug":"前端学习","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]}